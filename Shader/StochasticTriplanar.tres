[gd_resource type="Shader" format=2]

[resource]
code = "// NOTE: Shader automatically converted from Godot Engine 3.4.stable's SpatialMaterial.

shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_back,diffuse_burley,specular_schlick_ggx;
uniform vec4 albedo : hint_color;
uniform sampler2D texture_albedo : hint_albedo;
uniform float specular;
uniform float metallic;
uniform float roughness : hint_range(0,1);
uniform float point_size : hint_range(0,128);
uniform sampler2D texture_normal : hint_normal;
uniform float normal_scale : hint_range(-16,16);
varying vec3 uv1_triplanar_pos;
uniform float uv1_blend_sharpness;
varying vec3 uv1_power_normal;
uniform vec3 uv1_scale;
uniform vec3 uv1_offset;
uniform vec3 uv2_scale;
uniform vec3 uv2_offset;

// stochastic params
uniform bool method;
uniform sampler2D texture_noise : hint_albedo;

float sum( vec4 v ) { return v.x+v.y+v.z; }

vec2 hash2D2D (vec2 s)
{
    //magic numbers
    return fract(sin(mod(vec2(dot(s, vec2(127.1,311.7)), dot(s, vec2(269.5,183.3))), 3.14159))*43758.5453);
}
 
//stochastic sampling
vec4 textureStochastic(sampler2D tex, vec2 uv)
{
	float k = texture(texture_noise, 0.005 * uv).x; // cheap (cache friendly) lookup
   
    float l = k*8.0;
    float f = fract(l);
    float ia;
    float ib;
   
    if(method){
        ia = floor(l); // my method
        ib = ia + 1.0;
    }else{
        ia = floor(l+0.5); // suslik's method (see comments)
        ib = floor(l);
        f = min(f, 1.0-f)*2.0;
    }
    //triangle vertices and blend weights
    //BW_vx[0...2].xyz = triangle verts
    //BW_vx[3].xy = blend weights (z is unused)
    mat4 BW_vx;
 
    //uv transformed into triangular grid space with UV scaled by approximation of 2*sqrt(3)
    vec2 newUV = (mat2(vec2(1.0 , 0.0) , vec2(-0.57735027 , 1.15470054))* uv * 3.464);
 
    //vertex IDs and barycentric coords
    vec2 vxID = vec2 (floor(newUV));
    vec3 fracted = vec3 (fract(newUV), 0);
    fracted.z = 1.0-fracted.x-fracted.y;
 
    BW_vx = ((fracted.z>0.0) ?
        mat4(vec4(vxID, 0,0), vec4(vxID + vec2(0, 1), 0,0), vec4(vxID + vec2(1, 0), 0,0), vec4(fracted,0)) :
        mat4(vec4(vxID + vec2 (1, 1), 0,0), vec4(vxID + vec2 (1, 0), 0,0), vec4(vxID + vec2 (0, 1), 0,0), vec4(-fracted.z, 1.0-fracted.y, 1.0-fracted.x,0)));
 
    //calculate derivatives to avoid triangular grid artifacts
    vec2 dx = dFdx(uv);
    vec2 dy = dFdy(uv);
 
    //blend samples with calculated weights
    vec4 colora =  (textureGrad(tex, uv + hash2D2D(BW_vx[0].xy), dx, dy) * BW_vx[3].x +
	       textureGrad(tex, uv + hash2D2D(BW_vx[1].xy), dx, dy) * BW_vx[3].y +
           textureGrad(tex, uv + hash2D2D(BW_vx[2].xy), dx, dy) * BW_vx[3].z);
	vec4 colorb = (textureGrad(tex, uv + vec2(3,9) +hash2D2D(BW_vx[0].xy), dx, dy) * BW_vx[3].x +
	       textureGrad(tex, uv + vec2(3,9) + hash2D2D(BW_vx[1].xy), dx, dy) * BW_vx[3].y +
           textureGrad(tex, uv +vec2(3,9) + hash2D2D(BW_vx[2].xy), dx, dy) * BW_vx[3].z);
	return mix( colora, colorb, smoothstep(0.2,0.8,f-0.1*sum(colora-colorb)));
}
float aastep(float threshold, float value){
	float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
	return smoothstep(threshold-afwidth, threshold+afwidth, value);
}
vec4 textureaa(vec4 input, float threshold){
	return vec4(aastep(threshold, input.x), aastep(threshold, input.y), aastep(threshold, input.z), aastep(threshold, input.a));
}


void vertex() {
	TANGENT = vec3(0.0,0.0,-1.0) * abs(NORMAL.x);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.y);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.z);
	TANGENT = normalize(TANGENT);
	BINORMAL = vec3(0.0,1.0,0.0) * abs(NORMAL.x);
	BINORMAL+= vec3(0.0,0.0,-1.0) * abs(NORMAL.y);
	BINORMAL+= vec3(0.0,1.0,0.0) * abs(NORMAL.z);
	BINORMAL = normalize(BINORMAL);
	uv1_power_normal=pow(abs(NORMAL),vec3(uv1_blend_sharpness));
	uv1_power_normal/=dot(uv1_power_normal,vec3(1.0));
	uv1_triplanar_pos = VERTEX * uv1_scale + uv1_offset;
	uv1_triplanar_pos *= vec3(1.0,-1.0, 1.0);
}


vec4 triplanar_texture(sampler2D p_sampler,vec3 p_weights,vec3 p_triplanar_pos) {
	vec4 samp=vec4(0.0);
	samp+= textureStochastic(p_sampler,p_triplanar_pos.xy) * p_weights.z;
	samp+= textureStochastic(p_sampler,p_triplanar_pos.xz) * p_weights.y;
	samp+= textureStochastic(p_sampler,p_triplanar_pos.zy * vec2(-1.0,1.0)) * p_weights.x;
	return samp;
}


void fragment() {
	vec4 albedo_tex = triplanar_texture(texture_albedo,uv1_power_normal,uv1_triplanar_pos);
	ALBEDO = albedo.rgb * albedo_tex.rgb;
	METALLIC = metallic;
	ROUGHNESS = roughness;
	SPECULAR = specular;
	NORMALMAP = triplanar_texture(texture_normal,uv1_power_normal,uv1_triplanar_pos).rgb;
	NORMALMAP_DEPTH = normal_scale;
}
"
